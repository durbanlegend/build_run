Skipping unnecessary generation step. Use --force (-f) to override.
Skipping unnecessary build step. Use --force (-f) to override.
--------------------------------------------------
Type text wall at the prompt and hit Ctrl-D when done
Disentangled:
 1029  ./target/debug/runner --add "time json regex"
 1031  ./target/debug/runner --add "filetime"
 1043  ./target/debug/runner --add "serde_json"
 1044  runner --add "serde_json"
 1050  runner --crates
 1051  runner -e "10 + 20*4.5"
 1052  runner -e "10 + 20.*4.5"
 1053  runner -e "10. + 20*4.5"
 1054  runner -e "10. + 20.*4.5"
 1062  runner -e "1.2f64.sin()"
 1067  runner --add easy-shortcuts
 1087  runner --crates
 1088  runner --add io
 1093  runner -i '(0..5).map(|i| (10*i,100*i))'
 1098  runner -s hello.rs
 1099  runner --add r4
 1100  runner -s --macro r4 -i 'iterate![for x in 0..4; yield x]'
 1102  runner -C r4
 1104  $ runner -Xto_vec -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
runner -Xto_vec -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1105  $ runner -Xto_vec -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
runner -s -xtime -e "time::now()"
 1106  runner -s -xtime -e "time::now()"
 1107  runner --crates
 1108  runner --edit
 1110  runner --update
 1111  runner --crates
 1113  runner --build
 1115  runner -C universe.rs
 1116  runner -xuniverse -e "universe::answer()"
 1117  runner -s -xuniverse -e "universe::answer()"
 1118  runner --add universe
 1119  runner -s -xuniverse -e "universe::answer()"
 1120  runner -sN hello.rs
 1121  runner -s hello.rs
 1122  runner -N hello.rs
 1124  runner -i '(0..5).map(|i| (10*i,100*i))'
 1125  runner -s -i '(0..5).map(|i| (10*i,100*i))'
 1127  runner --libc hello.rs
 1129  runner -v hello.rs
 1130  runner -v hello.rs
 1131  runner -v hello.rs
 1133  runner -v hello.rs
 1135  runner --add time <<'EOF'
use time;
fn main(){
  println!("I'm from stdin! {}", time::now().rfc822z());
}
EOF
 1136  echo 'println!("Hi");' | runner -
 1137  echo 'println!("Hi");' | runner --stdin
 1138  runner -e << EOF
  println!("I'm from stdin! {}", time::now().rfc822z());
EOF
 1139  runner -e "{
  let good_result: Result<i32, i32> = Ok(10);
  let bad_result: Result<i32, i32> = Err(10);
  (good_result.map(|i| i + 1), bad_result.map(|i| i - 1))
}"
 1146  runner -v hello.rs
 1153  runner -v hello.rs
 1155  runner -v examples/hello.rs
 1296  find . -name runner -ls
 1301  runner -s filetime.rs
 1303  runner -c hello.rs
 1305  runner -d read.rs
 1307  runner -d json.rs
 1308  runner -d json.rs
 1309  runner -d json.rs
 1310  runner -d json.rs
 1311  runner -d json.rs
 1312  runner --add json
 1313  runner -d json.rs
 1314  runner -d json.rs
 1315  runner -d json.rs
 1316  runner -C json
 1317  runner -d json.rs
 1318  runner -s json.rs
 1322  runner -d json.rs
 1324  runner -d regex.rs
 1325  runner -s regex.rs
 1326  runner -s regex.rs
 1327  runner -P regex
 1329  runner -d regex
 1330  runner -d regex.rs
 1331  runner -C regex
 1332  runner -C regex_syntax
 1333  runner -C regex
 1334  runner -s regex.rs
 1335  runner -C memchr
 1336  runner -C aho-corasick
 1337  runner -add memchr
 1338  runner --add memchr
 1339  runner -C aho-corasick
 1340  runner -add memchr
 1341  runner --add memchr
 1342  runner -P memchr
 1343  runner -C aho-corasick
 1344  runner -C -s aho-corasick
 1354  runner -C aho-corasick
 1355  runner -C memchr
 1356  runner -C aho-corasick
 1358  find . -name runner -ls
 1363  zed $(runner -P aho-corasick)/Cargo.toml
 1364  zed $(runner -P memchr)/Cargo.toml
 1368  zed $(runner -P runner)/Cargo.toml
 1370  zed $(runner -P runner)/Cargo.toml
 1371  zed $(runner -P runner.rs)/Cargo.toml
 1425  runner -e 'stringify("Hi")'
 1426  runner -e 'stringify!("Hi")'
 1427  runner --crates | runner -n 'line.split(" ").take(1).last().unwrap()' | runner -n 'format!("runner -v --crates {line}")'
 1428  runner --crates | runner -n 'line.split(" ").take(1).last().unwrap()' | runner -n 'format!("runner -v --crates {line}")'
 1430  runner --crates | runner -n 'line.split(" ").take(1).last().unwrap()' | runner -n 'format!("runner -v --crates {line}")'
 1432  runner -c x.rs
 1433  runner -r x.rs
 1436  runner --crates | runner -n 'format!("runner -v --crates {}", line.split(" ").take(1).last().unwrap())'
 1437  runner -C thread_local
 1439  runner --add aho_corasick
 1440  runner --edit
 1443  runner --prepend "// pre
" mwe.rs
 1444  runner --prepend "// pre\
" mwe.rs
 1464  runner -e { x
 1465  x=`runner -e 'println!("xxx

xx");'`
 1466  x=`runner -e 'println!("xxx\
\
xx");'`
 1467  x=`runner -e 'println!("xxx\
\
xx")'`
 1472  runner -e '#![allow(unused)]
fn main() {
for c in "❤
!".escape_default() {
    print!("{c}");
}
println!();
}'
 1473  runner -e '#![allow(unused)]
fn main() {
for c in "❤
!".escape_default() {
    print!("{c}");
}
println!();
}'
 1474  runner -e 'let part1 = "This is a string";
let part2 = "
with a newline.";

let combined_string = format!("{}{}", part1, part2);

println!("{}", combined_string);
'
 1475  runner -e 'let formatted_string = format!("This is a string
with a newline.");

println!("{}", formatted_string);
'
 1476  runner -e '"This is a string
with a newline."'
 1477  runner -e 'format!("This is a string
with a newline.");'
 1481  runner -e 'format!("This is a string\
with a newline.");'
 1505  runner -s filetime.rs
 1506  runner -d filetime.rs
 1507  runner -Xto_vec -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1510  runner -Xto_vec -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].easy_shortcuts::to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1511  runner -Xto_vec -Mr4 -e 'easy_shortcuts::to_vec(iterate![for i in 0..2; for j in 0..2; yield (i,j)])'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1512  runner -Xeasy_shortcuts -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1516  runner -Xeasy_shortcuts -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1518  runner -Xeasy_shortcuts::traits::ToVec -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1520  runner --add easy_shortcuts
 1521  runner -Xeasy_shortcuts::traits::ToVec -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1522  runner -Xeasy_shortcuts::traits -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1524  runner -Xeasy_shortcuts -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1525  runner -p 'use crate::easy_shortcuts::traits::ToVec;' -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
[(0, 0), (0, 1), (1, 0), (1, 1)]
 1527  runner -p 'use crate::easy_shortcuts::traits::ToVec;' -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1530  runner -p 'use crate::easy_shortcuts::traits::ToVec' -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1532  runner -p 'use easy_shortcuts::traits::ToVec' -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1533  runner -x easy_shortcuts -p 'use easy_shortcuts::traits::ToVec' -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1535  runner -x easy_shortcuts -p 'use easy_shortcuts::traits::ToVec' -Mr4 -s  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1536  runner -x easy_shortcuts -p 'use easy_shortcuts::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1537  runner -P r4
 1538  runner -C r4
 1539  runner -C easy_shortcuts
 1540  runner -x easy_shortcuts -p 'use easy_shortcuts::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1541  runner --alias es=easy_shortcuts
 1542  runner -x es -p 'use easy_shortcuts::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1544  runner -x es -p 'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1545  runner -C es
 1546  runner -s --macro r4 -i 'iterate![for x in 0..4; yield x]'
 1548  runner -d --macro r4 -i 'iterate![for x in 0..4; yield x]'
 1549  runner -p 'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1550  runner -x es -p 'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1551  runner -xes -p'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1552  runner -s -xes -p'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1553  runner --add es
 1554  runner -s -xes -p'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1555  runner -xes -p'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1556  runner -P es
 1557  runner -P easy_shortcuts
 1559  runner --edit
 1560  runner --edit
 1561  runner -s -xeasy_shortcuts -p'use easy_shortcuts::traits::ToVec' -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1562  runner -s -xes -p'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1565  runner -s -xes -p'use es::traits::ToVec' -Mr4  -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1569  runner -p 'let nums=0..5' -i 'nums.clone().zip(nums.skip(1))'
 1570  runner -d -p 'let nums=0..5' -i 'nums.clone().zip(nums.skip(1))'
 1571  runner -s -p 'let nums=0..5' -i 'nums.clone().zip(nums.skip(1))'
 1574  runner -c universe.rs
 1575  runner -xuniverse -e "universe::answer()"
 1584  /Users/donf/orig_proj/runner_orig/target/debug/runner -C universe.rs
 1586  /Users/donf/orig_proj/runner_orig/target/debug/runner -C universe.rs
 1587  runner -c universe.rs
 1588  runner - universe.rs
 1589  runner -r universe.rs
 1592  runner -v
 1593  runner -V
 1601  RUST_BACKTRACE=1 runner -v examples/filetime.rs
 1608  RUST_BACKTRACE=1 runner -e <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1611  runner -V
 1612  runner -H
 1613  runner --help
 1614  runner -n <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}

EOF
 1615  runner -e -v <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}

EOF
 1616  runner -e -v <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}

EOF
 1617  runner -v -e << EOF
'{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
'
EOF
 1618  runner -e -v '{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
'
 1619  runner -e -v '{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}'
 1620  runner -vn
 1621  runner --expression <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1622  runner --expression <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1623  runner -e hello <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1624  runner -e stdin  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1625  runner -e --stdin  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1626  runner -e <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1627  runner -se <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1628  runner -se <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1629  runner -e "2 + 3"
 1630  runner -e "2 + 3"
 1631  runner -se <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1632  runner --edit-prelude
 1633  runner -Ne "2+3"
 1634  runner -E
 1635  runner --edition
 1636  runner -E 2018
 1637  runner -E 2018 -e "2+5"
 1638  runner -se <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1639  runner -se <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1640  runner -sI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1641  runner -sI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1642  runner -sI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1643  runner -sI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1644  runner -sI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1646  runner -E 2018 -e "2+5"
 1647  runner -sI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1648  runner -e {} <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1651  runner -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1654  runner -lines <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1655  runner --lines <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1656  runner -e <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1659  runner -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1661  runner -e 'use std::io::{self, Read};

fn main() -> Result<(), std::io::Error> {
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

    Ok(())
}'
 1662  runner -e 'use std::io::{self, Read};

fn main() -> Result<(), std::io::Error> {
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

    Ok(())
}' <<EOF
Hello
world
!
EOF
 1663  runner -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1665  runner -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1666  runner -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1668  runner -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1670  runner -s -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1671  runner -cI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1672  runner -cI
 1673  runner -s -I <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1674  runner -cI <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1675  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1676  runner -r fizzbuzz
 1677  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1678  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1679  runner --compile -I fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1683  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1684  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1685  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1686  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1687  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1688  runner -r fizzbuzz
 1689  runner -r fizzbuzz.rs
 1690  runner -r /Users/donf/.cargo/.runner/bin/fizzbuzz.rs
 1693  runner -cIs fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1698  echo $x | runner -I
 1699  echo $x | runner -Ic read_in <<EOF
use std::io::{self, Read};

fn main() -> Result<(), std::io::Error> {
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

    Ok(())
}
EOF
 1700  echo $x | runner -Ic read_in.rs <<EOF
use std::io::{self, Read};

fn main() -> Result<(), std::io::Error> {
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

    Ok(())
}
EOF
 1702  echo $x | runner -Ic read_in <<EOF
use std::io::{self, Read};

fn main() -> Result<(), std::io::Error> {
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

    Ok(())
}
EOF
 1710  runner -cI fizzbuzz1 <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1711  echo $x | runner -Ic read_in <<EOF 
{ use std::io::{self, Read};

fn main() -> Result<(), std::io::Error> {
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

    Ok(())
}
}
EOF
 1712  runner -Ic read_in <<EOF
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

EOF
 1720  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs
 1721  runner -r /Users/donf/.cargo/.runner/bin/read_in.rs
 1722  runner -r /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
2+2
EOF
 1723  runner -r /Users/donf/.cargo/.runner/bin/read_in.rs
 1724  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
2+2
EOF
 1726  runner -Ics read_in <<EOF
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

EOF
 1727  runner -Ics read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1728  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs
 1729  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello world!
EOF
 1730  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello world!
EOF
 1731  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Helloworld!
runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello world!
EOF
 1732  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Helloworld!
runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello world!
I said Hello!
Oh feck off!
EOF
 1769  runner -rd read_in.rs
 1771  runner -csI <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1772  runner -csI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1773  runner -rd /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1774  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1775  runner -cdI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1776  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1795  runner -d examples/hello.rs
 1796  runner -rd /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1797  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1798  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1799  runner -cdI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = std::io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1800  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1801  runner -rd /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1803  runner --crates
 1804  runner -csI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1805  runner -csI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1806  runner -csI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1807  runner -csI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1808  runner -c -sI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1809  runner --compile-only -sI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1810  runner -csI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1811  runner -rd /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1812  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1813  runner -cdI read_in <<EOF
let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);
EOF
 1814  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1815  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1816  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1817  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1819  runner -cd hello.rs
 1820  runner -rs hello.rs
 1821  runner -rd hello.rs
 1822  runner -cs hello.rs
 1823  runner -cs hello.rs
 1824  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1825  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1826  runner -rs /Users/donf/.cargo/.runner/bin/read_in.rs <<EOF
Hello
world!
EOF
 1827  runner -csI read_in.rs <<EOF
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

EOF
 1828  runner -cI read_in.rs <<EOF
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

EOF
 1830  runner -cI read_in.rs <<EOF
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

EOF
 1832  runner -cI read_in.rs <<EOF
    let mut buffer = String::new();

    // Read lines from stdin in a loop until EOF is reached
    loop {
        let bytes_read = io::stdin().read_line(&mut buffer)?;
        if bytes_read == 0 {
            break; // EOF reached
        }
    }

    println!("Content from stdin:
{}", buffer);

EOF
 1833  runner -cI fizzbuzz  <<EOF
{
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 1834  runner -rs fizzbuzz.rs
 1835  runner -rsI fizzbuzz.rs
 1836  runner -rsI /Users/donf/.cargo/.runner/bin/fizzbuzz.rs
 1837  runner -rs fizzbuzz.rs
 1838  runner -rsI /Users/donf/.cargo/.runner/bin/fizzbuzz.rs
 1839  runner -rs /Users/donf/.cargo/.runner/bin/fizzbuzz.rs
 1842  runner -ci hello.rs
 1845  runner -cd hello.rs
 1846  runner -rs hello.rs
 1847  runner -cd hello.rs
 1848  runner -rs hello.rs
 1849  runner -rs hello.rs
 1850  runner -cs hello.rs
 1851  runner -cs hello.rs
 1852  runner -rs hello.rs
 1857  runner --add regex
 1867  runner -x regex regex.rs
 1868  runner -s regex.rs
 1872  runner -s regex.rs
 1873  runner -s regex.rs
 1874  runner -I <<EOF
    use regex::Regex;
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    assert!(re.is_match("2014-01-01"));
    eprintln!("re={re:?}");

    let re = Regex::new(r"fn[[:space:]]+main").unwrap();
    let code = r#"
    fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    let mut buffer = String::new();

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }

        println!("Content from stdin:
{}", buffer);
    Ok(())
    }
    fn main() {
        if let Err(e) = run(std::env::args().collect()) {
            println!("error: {:?}",e);
        }
    }"#;

    assert!(re.is_match(code));
    eprintln!("re={re:?}");
EOF
 1875  runner -I <<EOF
    use regex::Regex;
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    assert!(re.is_match("2014-01-01"));
    eprintln!("re={re:?}");

    let re = Regex::new(r"fn[[:space:]]+main").unwrap();
    let code = r#"
    fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    let mut buffer = String::new();

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }

        println!("Content from stdin:
{}", buffer);
    Ok(())
    }
    fn main() {
        if let Err(e) = run(std::env::args().collect()) {
            println!("error: {:?}",e);
        }
    }"#;

    assert!(re.is_match(code));
    eprintln!("re={re:?}");
EOF
 1876  runner -I <<EOF
    use regex::Regex;
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    assert!(re.is_match("2014-01-01"));
    eprintln!("re={re:?}");

    let re = Regex::new(r"fn[[:space:]]+main").unwrap();
    let code = r#"
    fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    let mut buffer = String::new();

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }

        println!("Content from stdin:
{}", buffer);
    Ok(())
    }
    fn main() {
        if let Err(e) = run(std::env::args().collect()) {
            println!("error: {:?}",e);
        }
    }"#;

    assert!(re.is_match(code));
    eprintln!("re={re:?}");
EOF
 1879  runner -C regex
 1880  runner -C easy-shortcuts
 1881  runner -P
 1882  runner -P regex_automata
 1888  runner -C easy-shortcuts --features dummy
 1889  runner -C easy-shortcuts
 1890  runner -C regex_automata
 1891  runner -C regex_syntax
 1892  runner -C aho_corasick
 1893  runner -C memchr
 1894  runner -C aho_corasick
 1895  runner -C memchr
 1896  runner -C memchr
 1897  runner -C memchr
 1898  runner -c hello.rs
 1899  runner -cs hello.rs
 1900  runner -cs hello.rs
 1901  runner -rs hello.rs
 1902  runner -r hello.rs
 1903  runner -rd hello.rs
 1904  runner -rd hello.rs
 1905  runner -rd hello.rs
 1906  runner -rd hello.rs
 1907  runner -rd hello.rs
 1908  runner -rd hello.rs
 1909  runner -rd hello.rs
 1910  runner -rd hello.rs
 1911  runner -rd filetime.rs
 1912  runner -rd filetime.rs
 1916  runner -I << EOF
(1..10).product()
EOF
 1917  runner -I << EOF
(1..10).product();
EOF
 1918  runner -I << EOF
(1..10).iter().product();
EOF
 1919  runner -I << EOF
(1..=10).product();
EOF
 1920  runner -Is << EOF
(1..=10).product();
EOF
 1921  runner -Is << EOF
(1..=10).product::<i128>();
EOF
 1922  runner -e '(1..=10).product()'
 1923  runner -I <<EOF
pub fn answer() -> i32 {
    42
}
EOF
 1924  runner -I <<EOF
pub fn answer() -> i32 {
    42
}
EOF
 1925  runner -I <<EOF
pub fn answer() -> i32 {
    42
}
answer()
EOF
 1926  runner -I <<EOF
pub fn answer() -> i32 {
    42
}
answer();
EOF
 1928  runner -I <<EOF
println!("hello, world!");
EOF
 1929  runner -I <<EOF
pub fn answer() -> i32 {
    42
}
println!("{}", answer());
EOF
 1930  runner -I <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1931  runner -I <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1932  runner -I <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1935  runner -I <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1936  runner --add "itertools rug"
 1937  runner --add "itertools rug"
 1938  runner -I <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1939  runner -I -x rug -x itertools <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1940  runner -Is <<EOF
use itertools::iterate;
use rug::Integer;
use std::iter::successors;

fn main() {
    let fac = |n: usize| -> Integer {
        if n == 0 {
            Integer::from(0_usize)
        } else {
            (1..=n).map(Integer::from).product()
        }
    };

    // This works!
    let fib1 = |n: usize| -> usize {
        iterate((0, 1), |&(a, b)| (b, a + b))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    // This works too!
    let fib2 = |n: usize| -> usize {
        successors(Some((0, 1)), |&(a, b)| Some((b, a + b)))
            .take(n + 1)
            .last()
            .unwrap()
            .0
    };

    let limit = 50_usize;
    (0..=limit).for_each(|n| {
        println!("fibonacci({n})={}", fibonacci(n));
        println!("fib1({n})={}", fib1(n));
        println!("fib2({n})={}", fib2(n));
    });

    let mut prev = Integer::from(1);
    for n in 0..=limit {
        let factorial_n = factorial(n);
        // println!("factorial({n})={}", factorial_n);
        let fac_n = fac(n);
        println!("fac({n})={fac_n}");
        assert_eq!(fac_n, factorial_n);
        if n > 0 {
            assert_eq!(fac_n, prev * n);
            prev = fac_n;
        }
    }
}

fn factorial(n: usize) -> Integer {
    match n {
        0 | 1 => Integer::from(n),
        // _ => n * factorial(n - 1),
        _ => {
            let mut b = Integer::from(1_usize);
            for a in 2..=n {
                b *= a;
            }
            b
        }
    }
}

fn fibonacci(n: usize) -> usize {
    if n == 0 {
        n
    } else {
        let (mut a, mut b) = (0, 1);
        for _ in 1..n {
            (a, b) = (b, a + b);
        }
        b
    }
}
EOF
 1943  runner -I <<EOF
PathBuf::from('bonzo.dog').extension()
EOF
 1944  runner -I <<EOF
PathBuf::from("bonzo.dog").extension()
EOF
 1945  runner -I <<EOF
PathBuf::from("bonzo.dog").extension();
EOF
 1946  runner -e 'PathBuf::from("bonzo.dog").extension()'
 1947  runner -i 'env::args().enumerate()' one 'two 2' 3
 1948  echo "hello there" | runner -n 'line.to_uppercase()'
 1949  runner -xeasy_shortcuts -e 'easy_shortcuts::argn_err(1,"gimme an arg!")' 'an arg'
 1950  runner -xeasy_shortcuts -e 'easy_shortcuts::argn_err(1,"gimme an arg!")'
 1951  runner -xeasy_shortcuts -i 'easy_shortcuts::files(".")'
 1952  runner -xes -e 'es::argn_err(1,"gimme an arg!")'
 1953  runner -xes -e 'es::argn_err(1,"gimme an arg!")' 'Hello!"
'
 1954  runner -xes -e 'es::argn_err(1,"gimme an arg!")' 'Hello!'
 1955  runner -s -xtime -e "time::now()"
 1958  runner -xregex regex.rs
 1959  runner -d regex.rs
 1960  runner -I <<EOF
//: -s
use regex::Regex;
let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
assert!(re.is_match("2014-01-01"));
eprintln!("re={re:?}");
EOF
 1963  runner -C regex
 1964  runner -C "regex_syntax regex_automata memchr"
 1965  runner -C "regex_syntax"
 1966  runner -C regex_automata
 1967  runner -C regex_syntax
 1968  runner -C regex_automata
 1969  runner -C memrchr3
 1970  runner -C "memchr::memrchr3"
 1972  runner --libc memchr
 1973  runner --libc regex.rs
 1974  runner --libc -d regex.rs
 1975  runner --libc -d regex.rs
 1976  runner --libc regex.rs
 1978  runner --libc -I <<EOF
    let mut buffer = String::new();
    
        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }
    
        println!("Content from stdin:
{}", buffer);
    Ok(())
EOF
 1979  runner --libc -I <<EOF
    let mut buffer = String::new();
    
        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }
    
        println!("Content from stdin:
{}", buffer);
EOF
 1980  runner --libc -I -c read_in1 <<EOF
    let mut buffer = String::new();
    
        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }
    
        println!("Content from stdin:
{}", buffer);
EOF
 1981  runner -r read_in1 <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 1982  runner -r read_in1 <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 1983  runner -r read_in1 <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 1984  runner -r /Users/donf/.cargo/.runner/bin/read_in1.rs <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 1985  runner -r /Users/donf/.cargo/.runner/bin/read_in1.rs <<EOF
Running Little Rust Snippets
Leaving the Comfort (and Restrictions) of Cargo
Cargo is a good, reliable way to build programs and libraries in Rust with versioned dependencies. Those of us who have worked with the Wild West practices of C++ development find this particularly soothing, and it's one of the core strengths of the Rust ecosystem.

However, it's not intended to make running little test programs straightforward - you have to create a project with all the dependencies you wish to play with, and then edit src/main.rs and do cargo run. A useful tip is to create a src/bin directory containing your little programs and then use cargo run --bin NAME to run them. But there is a better way; if you have such a project (say called 'cache') then the following invocation will compile and link a program against those dependencies (rustc is an unusually intelligent compiler)

$ rustc -L /path/to/cache/target/debug/deps mytest.rs
EOF
 1986  runner --d r4
 1987  runner --doc r4
 1988  runner -s --macro r4 -i
 1989  runner -s --macro r4 -i '#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}'
 1990  runner -x es -p 'use es::traits::ToVec' -Mr4 -e 'iterate![for i in 0..2; for j in 0..2; yield (i,j)].to_vec()'
 1991  runner -x es -p 'use es::traits::ToVec; #[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }' -Mr4 -e 'iterate![for x in 0..10;
                           if let Some(y) = process(x);
                           yield y]
                  .to_vec()'
 1992  runner -x es -p 'use es::traits::ToVec; #[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }' -Mr4 -e 'iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .to_vec()'
 1993  runner -x es -p 'use es::traits::ToVec; #[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }' -Mr4 -e 'iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .to_vec()'
runner -x ee -I <<EOF
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
assert_eq!(v, w);EOF
 1994  runner -x es --stdin  <<EOF
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
assert_eq!(v, w);
EOF
 1995  runner -x es -p 'use es::traits::ToVec; #[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }' -Mr4 -e 'iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .to_vec()'
runner -x ee -I <<EOF
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
assert_eq!(v, w);EOF
 1996  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
assert_eq!(v, w);
EOF
 1997  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
assert_eq!(v, w);
EOF
 1998  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v}");

assert_eq!(v, w);
EOF
 1999  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2000  runner --doc es
 2001  runner --doc easy_shortcuts
 2002  runner --doc lapp
 2012  runner --doc lapp
 2014  runner --libc -I -c read_in1 <<EOF
    let mut buffer = String::new();
    
        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached
            }
        }
    
        println!("Content from stdin:
{}", buffer);
EOF
 2015  runner -r read_in1 <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 2016  runner -r read_in1 <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 2017  runner -r read_in1.rs <<EOF
And then you can run the json.rs example without -s.

The --compile action takes three kinds of arguments:

a crate name that is already loaded and known to Cargo
a Cargo directory
a Rust source file - the crate name is the file name without extension.
Dynamic linking is not a priority for Rust tooling at the moment. So we have to build more elaborate libraries without the help of Cargo. (The following assumes that you have already brought in regex for a Cargo project, so that the Cargo cache is populated, e.g. with runner --add regex)

EOF
 2018  runner -r /Users/donf/.cargo/.runner/bin/read_in1.rs <<EOF
Running Little Rust Snippets
Leaving the Comfort (and Restrictions) of Cargo
Cargo is a good, reliable way to build programs and libraries in Rust with versioned dependencies. Those of us who have worked with the Wild West practices of C++ development find this particularly soothing, and it's one of the core strengths of the Rust ecosystem.

However, it's not intended to make running little test programs straightforward - you have to create a project with all the dependencies you wish to play with, and then edit src/main.rs and do cargo run. A useful tip is to create a src/bin directory containing your little programs and then use cargo run --bin NAME to run them. But there is a better way; if you have such a project (say called 'cache') then the following invocation will compile and link a program against those dependencies (rustc is an unusually intelligent compiler)

$ rustc -L /path/to/cache/target/debug/deps mytest.rs
EOF
 2028  runner --help
 2029  runner -H
 2045  runner -d mwe.rs
 2046  runner -d mwe.rs
 2047  runner --add rand
 2048  runner -d mwe.rs
 2049  runner -d --libc mwe.rs
 2050  runner -s mwe.rs
 2051  runner -xrand mwe.rs
 2052  runner --doc rand
 2053  runner -I <<EOF
use rand::prelude::*;

if rand::random() { // generates a boolean
    // Try printing a random unicode code point (probably a bad idea)!
    println!("char: {}", rand::random::<char>());
}

let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2054  runner -s -I <<EOF
use rand::prelude::*;

if rand::random() { // generates a boolean
    // Try printing a random unicode code point (probably a bad idea)!
    println!("char: {}", rand::random::<char>());
}

let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2055  runner -s -I <<EOF
use rand::prelude::*;

if rand::random() { // generates a boolean
    // Try printing a random unicode code point (probably a bad idea)!
    println!("char: {}", rand::random::<char>());
}

let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2056  runner -s -I <<EOF
use rand::prelude::*;

if rand::random() { // generates a boolean
    // Try printing a random unicode code point (probably a bad idea)!
    println!("char: {}", rand::random::<char>());
} else { println!"No luck"); }

let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2057  runner -s -I <<EOF
use rand::prelude::*;

if rand::random() { // generates a boolean
    // Try printing a random unicode code point (probably a bad idea)!
    println!("char: {}", rand::random::<char>());
} else { println!"No luck"); }}

let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2058  runner -s -I <<EOF
use rand::prelude::*;

if rand::random() { // generates a boolean
    // Try printing a random unicode code point (probably a bad idea)!
    println!("char: {}", rand::random::<char>());
} else { println!("No luck"); }

let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2059  runner -s -I <<EOF
use rand::prelude::*;


println!("{}", rand::random::<usize>());


let mut rng = rand::thread_rng();
let y: f64 = rng.gen(); // generates a float between 0 and 1

let mut nums: Vec<i32> = (1..100).collect();
nums.shuffle(&mut rng);
EOF
 2060  runner -xrand mwe.rs
 2065  runner -s mwe.rs
 2066  runner -d --libc mwe.rs
 2071  runner -s examples/rand.rs
 2072  runner -s rand.rs
 2078  runner --docs rand
 2079  runner --doc rand
 2080  runner --doc regex
 2081  runner --doc lapp
 2086  runner --add lapp
 2087  runner --simplify --add lapp
 2090  runner --add lapp
 2128  runner --doc lapp
 2129  runner --doc lapp
 2130  runner --add lapp
 2131  runner --crates lapp
 2132  runner --add /Users/donf/projects/lapp
 2133  runner --doc lapp
 2134  runner --doc
 2135  runner -e <<EOF
{               
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}
EOF
 2136  runner -e '
{               
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}'
 2137  runner -e '
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
'
 2139  runner -e '
{               
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}'
 2140  runner -e '
{               
    use std::iter::{once, repeat};

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
        (i, ("", "")) => i.to_string(),
        (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
    });

    for line in fizz_buzz {
        println!("{}", line);
    }
}'
 2151  runner -e '#![allow(unused_imports)]                                       #![allow(unused_imports)]
#![allow(unused_variables)]                                     #![allow(unused_variables)]
#![allow(dead_code)]                                            #![allow(dead_code)]
#![allow(unused_macros)]                                        #![allow(unused_macros)]
use std::{fs,io,env};                                           use std::{fs,io,env};
use std::fs::File;                                              use std::fs::File;
use std::io::prelude::*;                                        use std::io::prelude::*;
use std::path::{PathBuf,Path};                                  use std::path::{PathBuf,Path};
use std::collections::HashMap;                                  use std::collections::HashMap;
use std::time::Duration;                                        use std::time::Duration;
use std::thread;                                                use std::thread;
                                                                
macro_rules! debug {                                            macro_rules! debug {
    ($x:expr) => {                                                  ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);                        println!("{} = {:?}",stringify!($x),$x);
    }                                                               }
}                                                               }
                                                                
                                                                
fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn s   fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn s
    println!("{:?}",                                                println!("{:?}",
                                                              >     {               
        use std::iter::{once, repeat};                                  use std::iter::{once, repeat};
                                                                    
        let fizzes = repeat("").take(2).chain(once("fizz")).c           let fizzes = repeat("").take(2).chain(once("fizz")).c
        let buzzes = repeat("").take(4).chain(once("buzz")).c           let buzzes = repeat("").take(4).chain(once("buzz")).c
        let fizzes_buzzes = fizzes.zip(buzzes);                         let fizzes_buzzes = fizzes.zip(buzzes);
                                                                    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tupl           let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tupl
            (i, ("", "")) => i.to_string(),                                 (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),               (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });                                                             });
                                                                    
        for line in fizz_buzz {                                         for line in fizz_buzz {
            println!("{}", line);                                           println!("{}", line);
        }                                                               }
    );                                                        |     });
    Ok(())                                                          Ok(())
}                                                               }
fn main() {                                                     fn main() {
    if let Err(e) = run(std::env::args().collect()) {               if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);                                      println!("error: {:?}",e);
    }                                                               }
}'
 2152  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",
        use std::iter::{once, repeat};
    
        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);
    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });
    
        for line in fizz_buzz {
            println!("{}", line);
        }
    );
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2153  runner -I <<EOF
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",
        use std::iter::{once, repeat};
    
        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);
    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });
    
        for line in fizz_buzz {
            println!("{}", line);
        }
    );
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
EOF
 2158  runner -I <<EOF
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]


#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    macro_rules! debug {
        (rsxpr) => {
            println!("{} = {:?}",stringify!(/Users/donf/.cargo/registry/src/index.crates.io-6f17d22bba15001f/lapp-0.4.0/src/lib.rs),/Users/donf/.cargo/registry/src/index.crates.io-6f17d22bba15001f/lapp-0.4.0/src/lib.rs);
        }
    }
    
    
    fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
        println!("{:?}",{            
            use std::iter::{once, repeat};
        
            let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
            let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
            let fizzes_buzzes = fizzes.zip(buzzes);
        
            let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
                (i, ("", "")) => i.to_string(),
                (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
            });
        
            for line in fizz_buzz {
                println!("{}", line);
            }
        );
        Ok(())
    }
    fn main() {
        if let Err(e) = run(std::env::args().collect()) {
            println!("error: {:?}",e);
        }
    }
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
}

EOF
 2159  runner -I <<EOF
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",
    {               
        use std::iter::{once, repeat};
    
        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);
    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });
    
        for line in fizz_buzz {
            println!("{}", line);
        }
    });
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
EOF
 2160  runner -I <<EOF
    {               
        use std::iter::{once, repeat};
    
        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);
    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });
    
        for line in fizz_buzz {
            println!("{}", line);
        }
    });
    Ok(())
}
EOF
 2163  runner -I <<EOF
 2164  runner -I <<EOF
    {               
        use std::iter::{once, repeat};
    
        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);
    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });
    
        for line in fizz_buzz {
            println!("{}", line);
        }
    }
EOF
 2165  runner -I <<EOF
        use std::iter::{once, repeat};
    
        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);
    
        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });
    
        for line in fizz_buzz {
            println!("{}", line);
        }
EOF
 2166  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",
        use std::iter::{once, repeat};

        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);

        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });

        for line in fizz_buzz {
            println!("{}", line);
        }
    );
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2167  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",
        use std::iter::{once, repeat};

        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);

        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });

        for line in fizz_buzz {
            println!("{}", line);
        }
    );
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2168  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::collections::HashMap;
use std::fs::File;
use std::io::prelude::*;
use std::path::{Path, PathBuf};
use std::thread;
use std::time::Duration;
use std::{env, fs, io};

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}", stringify!($x), $x);
    };
}

fn run(args: Vec<String>) -> std::result::Result<(), Box<dyn std::error::Error + Sync + Send>> {
    println!("{:?}", {
        use std::iter::{once, repeat};

        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);

        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });

        for line in fizz_buzz {
            println!("{}", line);
        }
    });
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}", e);
    }
}
'
 2169  runner -e '{#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::collections::HashMap;
use std::fs::File;
use std::io::prelude::*;
use std::path::{Path, PathBuf};
use std::thread;
use std::time::Duration;
use std::{env, fs, io};

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}", stringify!($x), $x);
    };
}

fn run(args: Vec<String>) -> std::result::Result<(), Box<dyn std::error::Error + Sync + Send>> {
    println!("{:?}", {
        use std::iter::{once, repeat};

        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);

        let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|tuple| match tuple {
            (i, ("", "")) => i.to_string(),
            (_, (fizz, buzz)) => format!("{}{}", fizz, buzz),
        });

        for line in fizz_buzz {
            println!("{}", line);
        }
    });
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}", e);
    }
}
}'
 2170  runner -e 'fn main() { println!("Hi!"); }
'
 2171  runner -e 'fn main() { println!("Hi!"); }'
 2172  runner -e '{fn main() { println!("Hi!"); }}'
 2190  runner -e `cat hi.rs`
 2194  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2206  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2209  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2210  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2211  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2212  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2213  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'| ;ess
 2214  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'| less
 2215  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2216  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2217  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2218  runner -I <<EOF
let mut output_path = PathBuf::from("~/.cargo/bin/metadata");
output_path.set_file_name("metadata");
output_path.to_str().unwrap()
EOF
 2219  runner -I <<EOF
let mut output_path = PathBuf::from("~/.cargo/bin/metadata");
output_path.set_file_name("metadata");
eprintln!("{output_path.to_str().unwrap()}");
EOF
 2220  runner -I <<EOF
let mut output_path = PathBuf::from("~/.cargo/bin/metadata");
output_path.set_file_name("metadata");
eprintln!("{}", output_path.to_str().unwrap());
EOF
 2221  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2223  runner -v --crate aho-corasick
 2224  runner -v --crates aho-corasick
 2225  zed $(runner -P aho-corasick)/Cargo.toml
 2226  zed $(runner -P regex)/Cargo.toml
 2227  runner -C memchr = "2.4.0"
 2228  runner -C memchr = "2.6.0"
 2229  runner -C aho-corasick
 2230  runner -dlib -C aho-corasick
 2231  runner --dlib -C aho-corasick
 2232  runner --libc -C aho-corasick
 2234  runner -d regex.rs
 2235  runner -C aho-corasick = "0.7.6"
 2236  runner -C aho-corasick = "1.0.0"
 2237  runner -C regex --features "default"
 2238  runner -C regex_syntax
 2239  runner -C regex --features "default"
 2240  runner -C regex_automata
 2241  runner -C regex_automata --features "alloc",
    "syntax, meta, nfa-pikevm"
 2242  runner -C regex_automata --features "alloc, syntax, meta, nfa-pikevm"
 2243  runner -C regex_syntax
 2244  runner -C regex_automata --features "alloc, syntax, meta, nfa-pikevm"
 2245  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2246  runner -e '#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_macros)]
use std::{fs,io,env};
use std::fs::File;
use std::io::prelude::*;
use std::path::{PathBuf,Path};
use std::collections::HashMap;
use std::time::Duration;
use std::thread;

macro_rules! debug {
    ($x:expr) => {
        println!("{} = {:?}",stringify!($x),$x);
    }
}


fn run(args: Vec<String>) -> std::result::Result<(),Box<dyn std::error::Error+Sync+Send>> {
    println!("{:?}",{fn main() { println!("Hi!"); }});
    Ok(())
}
fn main() {
    if let Err(e) = run(std::env::args().collect()) {
        println!("error: {:?}",e);
    }
}
'
 2247  runner -I <<EOF
hello
world!
EOF
 2250  runner -i '(0..5).map(|i| (10*i,100*i))'
 2266  runner -i '(0..5).map(|i| (10*i,100*i))'
 2267  runner -i '(0..5).map(|i| (10*i,100*i))'
 2268  runner -i '(0..5).map(|i| (10*i,100*i))'
 2269  runner -i '(0..5).map(|i| (10*i,100*i))'
 2270  runner -i '(0..5).map(|i| (10*i,100*i))'
 2271  runner -in <<EOF
a
b
c
EOF
 2272  runner -sn <<EOF
a
b
c
EOF
 2273  runner -n <<EOF
a
b
c
EOF
 2274  echo "a
b" | runner -n 'line.to_uppercase()'
 2275  echo "a
b" | runner -n 'line.to_uppercase()'
 2276  echo "hello
there" | runner -n 'line.to_uppercase()'
 2277  echo "a
b" | runner -n <<EOF
'line.to_uppercase()'
EOF
 2278  runner -xeasy_shortcuts -i 'easy_shortcuts::files(".")'
"json.rs"
"print.rs"
 2279  runner -xeasy_shortcuts -i 'easy_shortcuts::files(".")'
 2281  runner -i '(0..5).map(|i| (10*i,100*i))'
 2282  runner -i <<EOF
(0..5).map(|i| (10*i,100*i))
EOF
 2283  runner -i <<EOF
Hello world!
EOF
 2284  runner -i <<EOF
println!("Hello world!");
EOF
 2285  runner -Ii <<EOF
println!("Hello world!");
EOF
 2286  runner -iI <<EOF
(0..5).map(|i| (10*i,100*i))
EOF
 2287  runner -iI <<EOF
(0..5).map(|i| (10*i,100*i));
EOF
 2290  runner -i '(0..5).map(|i| (10*i,100*i))'
 2292  runner -i '(0..5).map(|i| (10*i,100*i))'
 2294  runner -iI <<EOF
(0..5).map(|i| (10*i,100*i))
EOF
 2296  runner -e 'for val in (0..5).map(|i| (10*i,100*i)) {
     println!("{:?}",val);
    }}
'
 2298  runner -e 'for val in (0..5).map(|i| (10*i,100*i)) {
     println!("{:?}",val);
    }
'
 2299  runner -e 'for val in (0..5).map(|i| (10*i,100*i)) {
     println!("{:?}",val);
    }
'
 2300  runner -eI <<EOF
for val in (0..5).map(|i| (10*i,100*i)) {
     println!("{:?}",val);
    }
EOF
 2301  runner -eI <<EOF
for val in (0..5).map(|i| (10*i,100*i)) {
     println!("{:?}",val);
    }
EOF
 2303  echo "hello
there" | runner -n 'line.to_uppercase()'
 2304  runner -n 'line.to_uppercase()'
 2305  runner -n 'line.to_uppercase()' <<EOF
hello
there
EOF
 2306  runner -nI 'line.to_uppercase()' <<EOF
hello
there
EOF
 2307   runner -I <<EOF
Hello
EOF
 2308   runner -I <<EOF
Hello
EOF
 2309   runner -Ie <<EOF
Hello
EOF
 2310   runner -Ie <<EOF
"Hello"
EOF
 2311   runner -Ie <<EOF
"Hello"
"world!"
runner -nI 'line.to_uppercase()' <<EOF
hello
there
EOF
 2312   runner -Ie <<EOF
"Hello"
"world!"
runner -nI 'line.to_uppercase()' <<EOF
hello
there
EOF
 2313   runner -nI 'line.to_uppercase()' <<EOF
hello
there
EOF
 2314   runner -Ie <<EOF
"Hello"
"world!"

EOF
 2315   runner -Ie <<EOF
"Hello"
"world!"

EOF
 2317   runner -Ie <<EOF
"Hello"
"world!"

EOF
 2319   runner -Ie <<EOF
"Hello"

EOF
 2320   runner -Ie <<EOF
"Hello"
EOF
 2321   runner -Ie <<EOF
"Hello"EOF
EOF
 2322   runner -Ie <<EOF
"Hello"EOF
EOF
 2323   runner -Ie <<EOF
"Hello"
EOF
 2324   runner -Ie <<EOF
"Hello"
EOF
 2325   runner -Ie <<EOF
"Hello"
EOF
 2326   runner -Ie <<EOF
"Hello"
EOF
 2327   runner -Ie <<EOF
"Hello"
EOF
 2328   runner -Ie <<EOF
"Hello"
EOF
 2329   runner -Ie <<EOF
"Hello"
EOF
 2331   runner -Ie <<EOF
"Hello"
EOF
 2332   runner -Ie <<EOF
"Hello"
EOF
 2333   runner -Ie <<EOF
"Hello"
EOF
 2343   runner -Ie <<EOF
"Hello"
EOF
 2344  runner -I <<EOF
use std::process::{Command, Stdio};

fn compile_and_get_output(source_code: &str) -> Result<String, String> {
  let mut rustc_process = Command::new("rustc")
      .args(&["-o", "/dev/null", "--emit=llvm-ir", "-"])  // Adjust args as needed
      .stdin(Stdio::piped())
      .spawn()
      .expect("Failed to spawn rustc process");

  let mut stdin = rustc_process.stdin.take().expect("Failed to get stdin pipe");
  stdin.write_all(source_code.as_bytes())
      .expect("Failed to write to stdin pipe");
  drop(stdin);

  let output = rustc_process.wait_with_output().expect("Failed to wait for rustc process");

  if !output.status.success() {
    Err(String::from_utf8_lossy(&output.stderr).to_string())
  } else {
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
  }
}

fn main() {
  let source_code = "// Your Rust source code here";
  let output = compile_and_get_output(source_code);
  match output {
    Ok(output_str) => println!("Rustc output:
{}", output_str),
    Err(err_msg) => println!("Error: {}", err_msg),
  }
}
EOF
 2345  runner -rI call_rustc << EOF
use std::process::{Command, Stdio};

fn compile_and_get_output(source_code: &str) -> Result<String, String> {
  let mut rustc_process = Command::new("rustc")
      .args(&["-o", "/dev/null", "--emit=llvm-ir", "-"])  // Adjust args as needed
      .stdin(Stdio::piped())
      .spawn()
      .expect("Failed to spawn rustc process");

  let mut stdin = rustc_process.stdin.take().expect("Failed to get stdin pipe");
  stdin.write_all(source_code.as_bytes())
      .expect("Failed to write to stdin pipe");
  drop(stdin);

  let output = rustc_process.wait_with_output().expect("Failed to wait for rustc process");

  if !output.status.success() {
    Err(String::from_utf8_lossy(&output.stderr).to_string())
  } else {
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
  }
}

fn main() {
  let source_code = "// Your Rust source code here";
  let output = compile_and_get_output(source_code);
  match output {
    Ok(output_str) => println!("Rustc output:
{}", output_str),
    Err(err_msg) => println!("Error: {}", err_msg),
  }
}
EOF
 2346  runner -cI call_rustc << EOF
use std::process::{Command, Stdio};

fn compile_and_get_output(source_code: &str) -> Result<String, String> {
  let mut rustc_process = Command::new("rustc")
      .args(&["-o", "/dev/null", "--emit=llvm-ir", "-"])  // Adjust args as needed
      .stdin(Stdio::piped())
      .spawn()
      .expect("Failed to spawn rustc process");

  let mut stdin = rustc_process.stdin.take().expect("Failed to get stdin pipe");
  stdin.write_all(source_code.as_bytes())
      .expect("Failed to write to stdin pipe");
  drop(stdin);

  let output = rustc_process.wait_with_output().expect("Failed to wait for rustc process");

  if !output.status.success() {
    Err(String::from_utf8_lossy(&output.stderr).to_string())
  } else {
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
  }
}

fn main() {
  let source_code = "// Your Rust source code here";
  let output = compile_and_get_output(source_code);
  match output {
    Ok(output_str) => println!("Rustc output:
{}", output_str),
    Err(err_msg) => println!("Error: {}", err_msg),
  }
}
EOF
 2347  runner -I /Users/donf/.cargo/.runner/bin/call_rustc.rs <<EOF
"Hello"
EOF
 2365  echo /Users/donf/.cargo/.runner/bin/call_rustc.rs | runner -Is
 2377  runner -eI <<EOF
"Hello"
EOF
 2378  runner -eI <<EOF
"Hello"
EOF
 2379  runner -eI <<EOF
"Hello"
EOF
 2380  runner -eI <<EOF
"Hello"
EOF
 2381  runner -eI <<EOF
"Hello"
EOF
 2382  runner -eIv <<EOF
"Hello"
EOF
 2383  runner -eI <<EOF
"Hello"
EOF
 2384  runner -eI <<EOF
"Hello"
EOF
 2385  runner -eIv <<EOF
"Hello"
EOF
 2386  runner -eIv <<EOF
"Hello"
EOF
 2387  runner --doc regex
 2388  runner -eIv <<EOF
"Hello"
EOF
 2389  runner -eI <<EOF
"Hello"
EOF
 2390  runner -eIs <<EOF
"Hello"
EOF
 2391  runner -eIs <<EOF
"Hello"
EOF
 2392  runner -eIv <<EOF
"Hello"
EOF
 2393  runner -i '(0..5).map(|i| 
'
 2394  runner -i '(0..5).map(|i| (10*i,100*i))'
 2396  runner -eIv <<EOF
"Hello"
EOF
 2399  runner -eIv <<EOF
"Hello"
EOF
 2400  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2403  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2404  runner -xes -e '#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);'
 2406  runner -ev '    #[derive(Debug, Eq, PartialEq)]
    struct Item { x: i32, y: i32, }
    
    let v: Vec<Item> = iterate![for x in 0..3;
                                for y in 5..7;
                                yield Item { x: x, y: y, }]
                       .collect();
    
    let mut w: Vec<Item> = Vec::new();
    for x in 0..3 {
      for y in 5..7 {
        w.push(Item { x: x, y: y, });
      }
    }
    println!("v={v:?}");
    
    assert_eq!(v, w););
'
 2407  runner -ev '    #[derive(Debug, Eq, PartialEq)]
    struct Item { x: i32, y: i32, }
    
    let v: Vec<Item> = iterate![for x in 0..3;
                                for y in 5..7;
                                yield Item { x: x, y: y, }]
                       .collect();
    
    let mut w: Vec<Item> = Vec::new();
    for x in 0..3 {
      for y in 5..7 {
        w.push(Item { x: x, y: y, });
      }
    }
    println!("v={v:?}");
    
    assert_eq!(v, w););
'
 2409  runner -ev '    #[derive(Debug, Eq, PartialEq)]
    struct Item { x: i32, y: i32, }
    
    let v: Vec<Item> = iterate![for x in 0..3;
                                for y in 5..7;
                                yield Item { x: x, y: y, }]
                       .collect();
    
    let mut w: Vec<Item> = Vec::new();
    for x in 0..3 {
      for y in 5..7 {
        w.push(Item { x: x, y: y, });
      }
    }
    println!("v={v:?}");
    
    assert_eq!(v, w););
'
 2410  runner -ev '#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }
                                
let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();
    
let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);'
 2411  runner -ev '#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }
                                
let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();
    
let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);'cat/Users/donf/.cargo/.runner/bin/tmp.rs
 2413  runner -x es --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2414  runner -eO '"Hello world!"'
 2415  runner -es '"Hello world!"'
 2416  runner -es 'Hello world!'
 2418  runner -x Ii --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2419  runner -Ii --stdin  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2420  runner -Ii  <<EOF
#[macro_use(iterate)] extern crate r4;
#[derive(Debug, Eq, PartialEq)]
struct Item { x: i32, y: i32, }

let v: Vec<Item> = iterate![for x in 0..3;
                            for y in 5..7;
                            yield Item { x: x, y: y, }]
                   .collect();

let mut w: Vec<Item> = Vec::new();
for x in 0..3 {
  for y in 5..7 {
    w.push(Item { x: x, y: y, });
  }
}
println!("v={v:?}");

assert_eq!(v, w);
EOF
 2422  runner -i '(0..5).map(|i| (10*i,100*i))'
 2423  runner -i '(0..50).map(|i| (10*i,100*i))'
 2424  runner -iOs '(0..=50).map(|i| (10*i,100*i))'
 2425  runner -iOs '(0..=50).map(|i| (10*i,100*i))' | runner -lIe
 2426  runner -iOs '(0..=50).map(|i| (10*i,100*i))' | runner -lines -Ie
 2427  runner -iOs '(0..=50).map(|i| (10*i,100*i))' | runner -lines -I
 2428  runner -iOs '(0..=50).map(|i| (10*i,100*i))'
 2429  runner -iOn '(0..=50).map(|i| (10*i,100*i))'
 2430  runner -On '(0..=50).map(|i| (10*i,100*i))'
 2431  runner -n '(0..=50).map(|i| (10*i,100*i))'
 2432  runner -i '(0..=50).map(|i| (10*i,100*i))'
 2433  runner -iO '(0..=50).map(|i| (10*i,100*i))'
 2437  runner -xtime=0.1.38 -e "time::now().rfc822z().to_string()"
 2438  runner -xtime -e "time::now().rfc822z().to_string()"
 2439  runner -s -xtime=0.1.38 -e "time::now().rfc822z().to_string()"
 2440  runner --add time=0.1.38
 2441  runner --add "time"=0.1.38
 2442  runner -add time
 2443  runner --add time
 2444  runner -e "time::now().rfc822z().to_string()"
 2445  runner --C time
 2446  runner -C time
 2448  runner --add "time_core powerfmt"
 2449  runner -C "time_core powerfmt"
 2450  runner -C "time_core"
 2451  runner -e "Systime::now().rfc822z().to_string()"
 2452  runner -e "SysTime::now().rfc822z().to_string()"
 2453  runner -I <<EOF
use std::time::{SystemTime, Duration};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2455  runner -I <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2456  runner -rI don -e <</Users/donf/.cargo/.runner/bin/tmp.rs
EOF
 2457  runner -rI don -e </Users/donf/.cargo/.runner/bin/tmp.rs
EOF
 2458  runner -cI don -e </Users/donf/.cargo/.runner/bin/tmp.rs
EOF
 2459  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -IcOs don
 2460  runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF        

EOF
 2461  runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF        

EOF
 2462  runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF        
 2463  runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF        

runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF        

EOF
 2464  runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF        

runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);

EOF
 2466  runner --libc -I -c read_in1 <<EOF                        
    let mut buffer = String::new();                 

        // Read lines from stdin in a loop until EOF is reached
        loop {
            let bytes_read = io::stdin().read_line(&mut buffer)?;
            if bytes_read == 0 {
                break; // EOF reached                                  
            }
        }                                                                             

        println!("Content from stdin:
{}", buffer);
EOF
 2468  runner --libc -I -c time_now <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2471  runner -r $x
 2472  runner -r $x.rs
 2474  runner -r $x
 2475  runner -r $x | runner -n
 2476  runner -r $x | runner -n <<EOF
Current time in SystemTime: SystemTime { tv_sec: 1710099852, tv_nsec: 306388000 }
Seconds since epoch: 1710099852
Milliseconds since epoch: 1710099852306
EOF
 2477  runner -r $x | runner -n 'line.to_lowercase()'
 2478  runner -r $x | tee runner -n 'line.to_lowercase()'
 2479  runner -r $x | tee runner -n 'line.find("epoch")'
 2480  runner -r $x | tee runner -n 'format!("{line:=>100}"'
 2482  runner -r $x | tee runner -n 'format!("{line:=>100}"'
 2483  runner -r $x | tee runner -n 'line.find("epoch")'
 2487  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -n 'format!("{}")'
 2488  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -n 'format!("{line}")'
 2489  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -n 'format!("{line}")'
 2491  runner -r $x | tee runner -n 'line.find("find")'
 2492  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -n 'line.find("find")''
'
 2493  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -n 'line.find("a")'
 2494  cat /Users/donf/.cargo/.runner/bin/tmp.rs | runner -n 'line.find("main")'
 2495  runner -i 'env::args().enumerate()' one 'two 2' 3
 2496  runner -s -xtime -e "time::now()"
 2501  runner -s-x time=0.1.38 -e "time::now().rfc822z().to_string()"
 2502  runner -sx time=0.1.38 -e "time::now().rfc822z().to_string()"
 2503  runner --crates
 2504  runner --add "time=0.1.38"
 2505  runner --edit
 2506  runner --build
 2507  runner --edit
 2508  runner --edit
 2509  runner --build
 2510  runner --edit
 2511  runner --build
 2512  runner -sx time=0.1.38 -e "time::now().rfc822z().to_string()"
 2513  runner -sx time=0.1.45 -e "time::now().rfc822z().to_string()"
 2514  runner --add "time=0.1.45"
 2515  runner -s --dlib -e "time::now().rfc822z().to_string()"
 2516  runner -s --libc -e "time::now().rfc822z().to_string()"
 2517  runner --crates
 2518  runner --edit
 2519  runner -s --libc -e "SysTime::now().rfc822z().to_string()"
 2520  runner -s --libc -e "std::time::SysTime::now().rfc822z().to_string()"
 2526  runner -rs /Users/donf/.cargo/.runner/bin/time_now
 2527  runner -rs /Users/donf/.cargo/.runner/bin/time_now.rs
 2528  runner -rs /Users/donf/.cargo/.runner/bin/time_now.rs
 2543  runner --edit
 2544  runner --build
 2545  runner --edit
 2567  runner -I <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2568  runner -Is <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2571  runner -vIs <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2572  runner -Is <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2573  runner -Idv <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2574  runner -Isv <<EOF
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2586  runner --crates -v
 2587  runner --crates --dep
 2588  runner --crates > /tmp/crates
 2591  runner -v --crates syn
 2592  runner -v --crates syn=1.0.109
 2619  runner -S testm.rs
 2621  runner --crates
 2622  runner --crates winnow
 2623  runner --crates -v winnow
 2624  runner -e "10 + 20*4.5"
 2625  runner -e "10 + 20.*4.5"
 2626  runner -e "10. + 20.*4.5"
 2628  runner -i '(0..5).map(|i| (10*i,100*i))'
 2629  runner -i 'env::args().enumerate()' one 'two 2' 3
 2630  echo "hello there" | runner -n 'line.to_uppercase()'
 2631  runner -xeasy_shortcuts -e 'easy_shortcuts::argn_err(1,"gimme an arg!")' 'an arg'
 2632  runner -xeasy_shortcuts -i 'easy_shortcuts::files(".")'
 2634  runner -xeasy_shortcuts -e 'easy_shortcuts::argn_err(1,"gimme an arg!")'
 2636  runner -xes  -i 'easy_shortcuts::files(".")'
 2637  runner -xes  -i 'es::files(".")'
 2638  runner -Isv <<EOF 
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2639  runner -Xs -Isv <<EOF 
use std::time::{SystemTime};

let now = now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2640  runner -Isv <<EOF 
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2641  runner -Idv <<EOF 
use std::time::{SystemTime};

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2643  runner -Idv <<EOF 
use std::time::{SystemTime};

let now = now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2644  runner -Xtime -Idv <<EOF 
use std::time::{SystemTime};

let now = now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2646  runner -Idv <<EOF 
use std::time;

let now = now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2647  runner -Idv <<EOF 
use std::time::*;

let now = now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2648  runner -Idv <<EOF 
use std::time::*;

let now = Systemtime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2649  runner -Idv <<EOF 
use std::time::*;

let now = std::Systemtime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2650  runner -Idv <<EOF 
use std::time::*;

let now = std::SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2651  runner -Idv <<EOF 
use std::time::*;

let now = Systemtime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2652  runner -Idv <<EOF 
use std::time::*;

let now = SystemTime::now();

// You can convert SystemTime to other time representations if needed
// (e.g., seconds since epoch, timestamp in milliseconds)
let secs_since_epoch = now.duration_since(SystemTime::UNIX_EPOCH).expect("Failed to get duration");
let millis_since_epoch = secs_since_epoch.as_millis();

println!("Current time in SystemTime: {:?}", now);
println!("Seconds since epoch: {}", secs_since_epoch.as_secs());
println!("Milliseconds since epoch: {}", millis_since_epoch);
EOF
 2660  runner --macro r4 -i 'iterate![for x in 0..4; yield x]'
 2661  runner -I <<EOF
// json.rs
use json;

let parsed = json::parse(r#"

{
    "code": 200,
    "success": true,
    "payload": {
        "features": [
            "awesome",
            "easyAPI",
            "lowLearningCurve"
        ]
    }
}

"#)?;

println!("{}",parsed);EOF
EOF
 2662  runner -I <<EOF
// json.rs
use json;

let parsed = json::parse(r#"

{
    "code": 200,
    "success": true,
    "payload": {
        "features": [
            "awesome",
            "easyAPI",
            "lowLearningCurve"
        ]
    }
}

"#)?;

println!("{}",parsed);
EOF
 2663  runner -Id <<EOF
// json.rs
use json;

let parsed = json::parse(r#"

{
    "code": 200,
    "success": true,
    "payload": {
        "features": [
            "awesome",
            "easyAPI",
            "lowLearningCurve"
        ]
    }
}

"#)?;

println!("{}",parsed);
EOF
 2664  runner -d json.rs
 2665  runner -d -M serde_json json.rs
 2666  runner -d -M serde_json json.rs
 2667  runner -d -M serde_json json.rs
 2668  runner -d -M serde_json json.rs
 2669  runner -d json.rs
 2670  runner -d -S json.rs
 2671  runner -d -S json.rs
 2672  runner -d -S json.rs
 2673  runner -s -S json.rs
 2674  runner -v --crates
 2675  runner -Cv serde_json
 2676  runner -v --crates serde_json
 2682  runner --edit
 2683  runner --edit
 2684  runner -v --build
 2685  runner -d -S json.rs
 2686  runner -C serde_json
 2687  runner -C serde
 2688  runner -C serde_json
 2689  runner -d -S json.rs
 2691  zed $(runner -P serde_json)/Cargo/toml
 2692  zed $(runner -P serde_json)/Cargo.toml
 2693  runner -v --caches
 2694  runner -v --crates
 2695  runner -C serde_json
 2697  runner -d -S json.rs
 2698  zed $(runner -P serde)/Cargo.toml
 2699  runner -xes -e 'es::argn_err(1,"gimme an arg!")' yabbadabbadoo
 2700  runner -p 'let nums=0..5' -i 'nums.clone().zip(nums.skip(1))'
 2702  runner -xuniverse -e "universe::answer()"
 2703  runner -I
 2704  runner -CI
 2707  runner -C text.rs
 2708  runner -Xtext -e 'TEXT.find("long")'
 2709  runner -n 'line.find("long")'
 2710  runner -sN filetime.rs
 2712  runner -sN filetime.rs
 2713  runner -s filetime.rs
 2718  runner -v hello.rs
 2722  runner --crates syn
 2733  runner -d -S json_alt.rs
 2736  runner -d -S json_alt.rs
 2737  runner -d -S json_alt.rs
 2743  runner -d -S json_alt.rs
 2746  runner -d -S json_alt.rs
 2747  runner -d -S json_alt.rs
 2748  runner -d -S json_alt.rs
 2749  runner -d -S json_alt.rs
 2750  runner -d -S json_alt.rs
 2751  runner -S json_alt.rs
 2752  runner -S json_alt.rs
 2753  runner -S json_alt.rs
 2754  runner -S json_alt.rs
 2755  runner -S json_alt.rs
 2756  runner -S json_alt.rs
 2757  runner -S json_alt.rs
 2758  runner -S json_alt.rs
 2759  runner -S json_alt.rs
 2760  runner -S json_alt.rs
 2761  runner -S json_alt.rs
 2762  runner -S json_alt.rs
 2763  runner -S json.rs
 2766  runner -S json_alt.rs
 2767  runner -S json_alt.rs
 2770  runner -S json_alt.rs
 2771  runner -S json_alt.rs
 2772  runner -S json_alt.rs
 2773  runner -S json_alt.rs
 2774  runner -S json_alt.rs
 2775  runner -S json_alt.rs
 2778  runner -S json_alt.rs
 2781  runner -S json_alt.rs
 2786  runner -S json_alt.rs
 2788  runner -S json_alt.rs
 2789  runner --crates
 2790  runner --add "time json regex"
 2792  runner -S json_alt.rs
 2793  runner -S json_alt.rs
 2794  runner -S json_real.rs
 2795  runner -S json_real.rs
 2796  runner -S json_real.rs
 2798  runner -S testm.rs
 2801  runner --doc std
 2802  runner --doc std
 2804  runner -S testm.rs
 2805  runner -S testm.rs
 2806  runner -Sv testm.rs
 2807  runner -Sv testm.rs
 2808  runner -Sv testm.rs
 2809  runner -Sv testm.rs
 2810  runner -e '{ let mut map: std::collections::HashMap<String,String> = HashMap::new();
    map.insert("hello".to_string(),"dolly".to_string()) }'
 2811  runner -e '{ let mut map: std::collections::HashMap<String,String> = HashMap::new();
    map.insert("hello".to_string(),"dolly".to_string()) }'
 2812  runner -e '{ let mut map: std::collections::HashMap<String,String> = HashMap::new();
    map.insert("hello".to_string(),"dolly".to_string()) }'
 2813  runner -e '
{ let mut map: std::collections::HashMap<String,String> = HashMap::new();
    map.insert("hello".to_string(),"world".to_string());
    map.insert("hello".to_string(),"dolly".to_string()) }
'
 2814  runner -I
 2815  runner -eI
 2816  runner -eIv
 2818  runner -e "2*3"
 2820  runner -eI
 2821  runner -eIS
 2822  runner -eIS
 2823  runner -eI
 2824  runner -eI
 2825  runner -eI
 2826  runner -eI
 2827  runner -eI
 2828  runner -eIS
 2829  runner -eIS
 2830  runner -eIS
 2831  runner -eIS
 2832  runner -eISv
 2833  runner -eISv
 2834  runner -eISv
 2835  runner -eISv
 2836  runner -eISv
 2837  runner -eISv
 2838  runner -eISvr map.rs
 2839  runner -eISv
 2840  runner -eISvr < testm.rs
 2841  runner -eISr < testm.rs
 2842  runner -eISC testm_build.rs
 2843  runner -eISCV testm_build.rs
 2844  runner -eISCV testm_build.rs
 2845  runner -eISCV testm_build.rs
 2846  runner -eISCV testm_build.rs
 2847  runner -eISCV testm_build.rs
 2848  runner -eISCv testm_build.rs
 2849  runner -eIScv testm_build.rs
 2850  runner -eIScv
 2851  runner -eISv
 2859  runner -s eval_bool.rs
 2860  runner -eIScv testm_build.rs
 2863  runner -eIScv testm_build.rs
 2864  runner -eIScv testm_build.rs < testm.rs
 2865  runner -eIScvs testm_build.rs < testm.rs
 2866  runner -rv /Users/donf/.cargo/.runner/bin/testm_build.rs
 2867  runner -rv /Users/donf/.cargo/.runner/bin/testm_build.rs
 2868  runner -srv /Users/donf/.cargo/.runner/bin/testm_build.rs
 2869  runner -rv /Users/donf/.cargo/.runner/bin/testm_build.rs
 2870  runner -srv /Users/donf/.cargo/.runner/bin/testm_build.rs
 2878  runner -eI <testm_ok.rs
 2879  runner -eI <testm_ok.rs
 2880  runner -eI <testm_ok.rs
 2881  runner -eI <testm_ok.rs
 2882  runner -eI <testm_ok.rs
 2883  runner -eIv <testm_ok.rs
 2884  runner -eIv <testm_ok.rs
 2885  runner -eIvs <testm_ok.rs
 2886  runner -eIvs <testm_ok.rs
 2887  runner -eIvs <testm_ok.rs
 2888  runner -eIv <testm_ok.rs
 2889  runner -eIv <testm_ok.rs
 2892  runner -rs $x
 2893  runner -rsv $x
 2894  runner -rdv $x
 2895  runner -rdv $x
 2896  runner -rv $x
 2897  runner -rsv $x
 2898  runner -rsv $x
 2899  runner --doc lapp
 2901  runner -rsv $x
 2902  runner -rsv $x
 2903  runner -sv $x
 2904  runner -v $x
 2905  runner -v $x
 2906  runner -eI <testm_ok.rs
 2907  runner -eIv <testm_ok.rs
 2908  runner -eIvsd <testm_ok.rs
 2909  runner -eIvsd <testm_ok.rs
 2910  runner -sv $x
 2914  runner -v $x
 2916  runner -v $x
 2917  runner -v $x
 2920  runner -v $x
 2921  runner -vd $x
 2933  runner -rsv $x
 2934  runner -rdv $x
 2936  runner -rdv $x
 2943  runner -rsv $x
 2946  runner -rsv $x
 2948  runner -rsv $x
 2994  runner -v hello.rs
 2995  runner -eIvsd <testm_ok.rs
 2996  runner -eIvsd <testm_ok.rs
 2997  runner -eIvsd <testm_ok.rs
 2998  runner -s eval_bool.rs
 2999  history } grep '^runner -'
 3000  history | grep '^runner -'
 3001  history | grep 'runner -'
 3002  history -1000 | grep 'runner -'
 3003  history -10000 | grep 'runner -' > x
 3005  cat x | runner -n 'line.split(" ").iter().skip(1).fold("", |x| ac
 3006  examples % cat x | runner -n 'line.split(" ").iter().skip(1).fold("", |acc, x| acc + " " + x)'
 3007  examples % cat x | runner -n 'line.split(" ").skip(1).fold("", |acc, x| acc + " " + x)'
 3008  cat x | runner -n 'line.split(" ").skip(1).fold("", |acc, x| acc + " " + x)'
 3009  cat x | runner -n 'line.split(" ").skip(1).fold("", |acc, x| acc.to_owned() + " " + x)'
 3010  cat x | runner -n 'line.split(" ").skip(1).fold("", |acc, x| &(acc.to_owned() + " " + x))'
 3011  cat x | runner -n 'line.split(" ").skip(1).fold(String::new(), |acc, x| acc.to_owned() + " " + x)'
 3014  cat x | runner -n 'line.split(" ").skip(2).fold(String::new(), |acc, x| acc.to_owned() + " " + x)'
 3015  cat x | runner -n 'line.trim_left().split(" ").skip(1).fold(String::new(), |acc, x| acc.to_owned() + " " + x)'
 3017  cat x | runner -n 'line.trim_left().split(" ").skip(1).fold(String::new(), |acc, x| (acc.to_owned() + " " + x).trim_left)'
 3018  cat x | runner -n 'line.split(" ").skip(1).fold(String::new(), |acc, x| (acc.to_owned() + " " + x).trim_start())'
 3019  cat x | runner -n 'line.split(" ").skip(1).fold(String::new(), |acc, x| (acc.to_owned() + " " + x).trim_start().to_owned)'
 3020  cat x | runner -n 'line.split(" ").skip(1).fold(String::new(), |acc, x| (acc.to_owned() + " " + x).trim_start().to_owned())'


--------------------------------------------------
Completed run in 0.195s
build_run completed processing script unescape_nl2.rs in 0.199s
