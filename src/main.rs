use std::env;
use std::error::Error;
// use std::fs::File;
use std::process::Command;
use std::{fs, io::Write};

// use env_logger::Builder;
// use env_logger::{Env, WriteStyle};
use std::path::{Path, PathBuf}; // Use PathBuf for paths

use log::{debug, LevelFilter};

mod errors;

fn build_and_run_rust(
    source_stem: &str,
    source: &str,
    cargo_manifest: &str,
) -> Result<String, errors::BuildRunError> {
    // Define the dedicated directory for the manifest
    let build_dir = PathBuf::from(".cargo/build_run");

    // Ensure the directory exists (create it if needed)
    if !build_dir.exists() {
        fs::create_dir_all(&build_dir)?; // Use fs::create_dir_all for directories
    }

    // Write source code to a file within the directory
    let source_path = build_dir.join("tmp_source.rs"); // Join paths with PathBuf
    let mut source_file = fs::File::create(&source_path)?;
    source_file.write_all(source.as_bytes())?;
    eprintln!("Source path: {source_path:?}");

    let tmp_source = fs::read_to_string(PathBuf::from(
        "/Users/donf/projects/build_run/.cargo/build_run/tmp_source.rs",
    ))?;
    tmp_source.lines().for_each(|line| eprintln!("{line}"));

    let relative_path = source_path;

    let mut absolute_path = std::env::current_dir()?;
    absolute_path.push(relative_path);
    eprintln!("Absolute path of generated program: {absolute_path:?}");

    // Write Cargo.toml content to a file within the directory
    let cargo_toml_path = build_dir.join("Cargo.toml");
    let mut cargo_toml = fs::File::create(&cargo_toml_path)?;
    cargo_toml.write_all(cargo_manifest.as_bytes())?;

    debug!("cargo_toml_path={cargo_toml_path:?}");
    let cargo_toml_contents = fs::read_to_string(&cargo_toml_path)?;
    eprintln!("Cargo.toml contents:");
    cargo_toml_contents
        .lines()
        .for_each(|line| eprintln!("{line}"));

    // Build the Rust program using Cargo (with manifest path)
    let mut build_command = Command::new("cargo");
    build_command
        .args(["build", "--verbose"])
        .current_dir(build_dir.clone());
    eprintln!("build_dir={build_dir:?}, build_command={build_command:?}");
    let build_output = build_command.output()?;

    if build_output.status.success() {
        let success_msg = String::from_utf8_lossy(&build_output.stdout);
        eprintln!("##### Build succeeded!");
        success_msg.lines().for_each(|line| {
            eprintln!("{line}");
        });
    } else {
        let error_msg = String::from_utf8_lossy(&build_output.stderr);
        return Err(errors::BuildRunError::Command(format!(
            "Cargo build failed: {error_msg}"
        )));
    }

    // Run the built program
    let mut run_command = Command::new(format!("./target/debug/{source_stem}")); // Replace with actual program name
    run_command.current_dir(build_dir);
    let run_output = run_command.output()?;

    if !run_output.status.success() {
        let error_msg = String::from_utf8_lossy(&run_output.stderr);
        return Err(errors::BuildRunError::Command(format!(
            "Program execution failed: {error_msg:?}"
        )));
    }

    let output = String::from_utf8_lossy(&run_output.stdout);
    Ok(output.to_string())
}

fn main() -> Result<(), Box<dyn Error>> {
    let start = std::time::Instant::now();

    // Configure log level
    // let env = Env::new().filter("RUST_LOG"); //.default_write_style_or("auto");
    // let mut binding = Builder::new();
    // let builder = binding.parse_env(env);
    // builder.write_style(WriteStyle::Always);
    // builder.init();
    // Configure log level
    env_logger::Builder::new()
        .filter_level(LevelFilter::Debug)
        .init();

    // Example source code and Cargo.toml content
    let source_stem = "factorial_main";
    let source_name = format!("{source_stem}.rs");
    let project_dir = env::var("PWD")?; // Set during cargo build
    let project_path = PathBuf::from(project_dir);
    // let target_dir = project_path.join("target");
    let mut code_path: PathBuf = project_path.join("examples");

    code_path.push(source_name);
    let source = read_rs_file_contents(&code_path)?;
    //       format!(
    //       r##"
    // fn main() {{
    //   println!("Hello from program {source_stem}, programmatically generated by Cargo!");
    // }}
    // "##
    //   );

    let cargo_manifest = format!(
        r##"
    [package]
    name = "{source_stem}"
    version = "0.0.1"
    edition = "2021"

    [dependencies]
    rug = {{ version = "1.24.0", features = ["integer"] }}

    [workspace]

    [[bin]]
    name = "{source_stem}"
    path = "/Users/donf/projects/build_run/.cargo/build_run/tmp_source.rs"
    "##
    );

    let result = build_and_run_rust(source_stem, &source, &cargo_manifest);

    match result {
        Ok(output) => {
            println!("Build output:");
            output.lines().for_each(|line| eprintln!("{line}"));
        }
        Err(error) => {
            println!("Error: {error}");
        }
    }
    let dur = start.elapsed();
    eprintln!("Completed in {}.{}s", dur.as_secs(), dur.subsec_millis());
    debug!("Completed in {}.{}s", dur.as_secs(), dur.subsec_millis());

    Ok(())
}

fn read_rs_file_contents(path: &Path) -> Result<String, Box<dyn Error>> {
    eprintln!("Reading from {path:?}");
    Ok(fs::read_to_string(path)?)
}
